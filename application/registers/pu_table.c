#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "gd32f303e_eval.h"
#include "pu_table.h"

typedef struct {
    uint32_t address;
    uint32_t offset;
    uint32_t status;
    uint32_t type;
    uint32_t length;
    uint32_t data;
    uint32_t command;
} PUData;

static PUData registers[] = {
    {0x0000, 0x0000, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0000, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0004, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0008, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x000C, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0010, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0014, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0018, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x001C, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0020, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0024, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0028, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x002C, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0030, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0034, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0038, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x003C, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0040, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0044, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0048, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x004C, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0050, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0054, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0058, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x005C, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0060, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0064, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0068, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x006C, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0070, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0074, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0078, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x007C, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0080, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0084, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0088, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x008C, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0090, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0094, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0098, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x009C, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00A0, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00A4, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00A8, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00AC, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00B0, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00B4, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00B8, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00BC, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00C0, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00C4, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00C8, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00CC, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00D0, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00D4, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00D8, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00DC, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00E0, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00E4, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00E8, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00EC, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00F0, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00F4, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00F8, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x00FC, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0100, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0104, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0108, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x010C, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x010E, 0, 'W', 4, 0x0, 0x0},
    {0x1000, 0x0110, 0, 'W', 4, 0x0, 0x0},
    {0x1200, 0x0000, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x0002, 0, 'R', 4, 0x0, 0x14},
    {0x1200, 0x0004, 0, 'R', 4, 0x0, 0x16},
    {0x1200, 0x0006, 0, 'R', 4, 0x0, 0x18},
    {0x1200, 0x0008, 0, 'R', 4, 0x0, 0x1A},
    {0x1200, 0x000A, 0, 'R', 4, 0x0, 0x1C},
    {0x1200, 0x000C, 0, 'R', 4, 0x0, 0x1E},
    {0x1200, 0x000E, 0, 'R', 4, 0x0, 0x20},
    {0x1200, 0x0010, 0, 'R', 4, 0x0, 0x22},
    {0x1200, 0x0012, 0, 'R', 4, 0x0, 0x24},
    {0x1200, 0x0014, 0, 'R', 4, 0x0, 0x26},
    {0x1200, 0x0016, 0, 'R', 4, 0x0, 0x28},
    {0x1200, 0x0018, 0, 'R', 4, 0x0, 0x2A},
    {0x1200, 0x001A, 0, 'R', 4, 0x0, 0x2C},
    {0x1200, 0x001C, 0, 'R', 4, 0x0, 0x2E},
    {0x1200, 0x001E, 0, 'R', 4, 0x0, 0x30},
    {0x1200, 0x0020, 0, 'R', 4, 0x0, 0x32},
    {0x1200, 0x0022, 0, 'R', 4, 0x0, 0x34},
    {0x1200, 0x0024, 0, 'R', 4, 0x0, 0x36},
    {0x1200, 0x0026, 0, 'R', 4, 0x0, 0x38},
    {0x1200, 0x0028, 0, 'R', 4, 0x0, 0x3A},
    {0x1200, 0x002A, 0, 'R', 4, 0x0, 0x62},
    {0x1200, 0x002C, 0, 'R', 4, 0x0, 0x64},
    {0x1200, 0x002E, 0, 'W', 4, 0x0, 0x66},
    {0x1200, 0x0030, 0, 'R', 4, 0x0, 0x68},
    {0x1200, 0x0032, 0, 'R', 4, 0x0, 0x6A},
    {0x1200, 0x0034, 0, 'R', 4, 0x0, 0x6C},
    {0x1200, 0x0036, 0, 'R', 4, 0x0, 0x6E},
    {0x1200, 0x0038, 0, 'R', 4, 0x0, 0x70},
    {0x1200, 0x003A, 0, 'R', 4, 0x0, 0x72},
    {0x1200, 0x003C, 0, 'R', 4, 0x0, 0x74},
    {0x1200, 0x003E, 0, 'R', 4, 0x0, 0x76},
    {0x1200, 0x0040, 0, 'R', 4, 0x0, 0x78},
    {0x1200, 0x0042, 0, 'R', 4, 0x0, 0x7A},
    {0x1200, 0x0044, 0, 'R', 4, 0x0, 0x7F},
    {0x1200, 0x0046, 0, 'R', 4, 0x0, 0x02},
    {0x1200, 0x0048, 0, 'R', 4, 0x0, 0x03},
    {0x1200, 0x004A, 0, 'R', 4, 0x0, 0x04},
    {0x1200, 0x004C, 0, 'R', 4, 0x0, 0x05},
    {0x1200, 0x004E, 0, 'R', 4, 0x0, 0x06},
    {0x1200, 0x0050, 0, 'R', 4, 0x0, 0x07},
    {0x1200, 0x0052, 0, 'R', 4, 0x0, 0x0A},
    {0x1200, 0x0054, 0, 'R', 4, 0x0, 0x0B},
    {0x1200, 0x0056, 0, 'R', 4, 0x0, 0x0C},
    {0x1200, 0x0058, 0, 'R', 4, 0x0, 0x0D},
    {0x1200, 0x005A, 0, 'R', 4, 0x0, 0x0E},
    {0x1200, 0x005C, 0, 'R', 4, 0x0, 0x0F},
    {0x1200, 0x005E, 0, 'R', 4, 0x0, 0x10},
    {0x1200, 0x0060, 0, 'R', 4, 0x0, 0x11},
    {0x1200, 0x0062, 0, 'R', 4, 0x0, 0x12},
    {0x1200, 0x0064, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x0066, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x0068, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x006A, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x006C, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x006E, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x0070, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x0072, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x0074, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x0076, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x0078, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x007A, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x007C, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x007E, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x0080, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x0082, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x0084, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x0086, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x0088, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x008A, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x008C, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x0090, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x0094, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x0098, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x009C, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x009E, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00A0, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00A4, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00A6, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00A8, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00AC, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00B0, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00B4, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00B8, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00BA, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00BC, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00C0, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00C2, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00C4, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00C6, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00C8, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00CA, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00CC, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00CE, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00D0, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00D2, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00D4, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00D6, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00D8, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00DA, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00DC, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00E0, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00E2, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00E4, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00E6, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00E8, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00EA, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00EE, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00F2, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00F4, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00F6, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00F8, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x00FC, 0, 'R', 4, 0x0, 0x0},
    {0x1200, 0x0100, 0, 'R', 4, 0x0, 0x0},
    {0x1400, 0x0000, 0, 'R', 4, 0x0, 0x0},
    {0x1400, 0x0004, 0, 'R', 4, 0x0, 0x0},
    {0x1400, 0x0008, 0, 'R', 4, 0x0, 0x0},
    {0x1400, 0x000C, 0, 'R', 4, 0x0, 0x0},
    {0x1400, 0x0010, 0, 'R', 4, 0x0, 0x0},
    {0x1400, 0x0014, 0, 'R', 4, 0x0, 0x0},
    {0x1400, 0x0018, 0, 'R', 4, 0x0, 0x0},
    {0x1400, 0x001C, 0, 'R', 4, 0x0, 0x0},
    {0x1400, 0x0020, 0, 'R', 4, 0x0, 0x0},
    {0x1400, 0x0024, 0, 'R', 4, 0x0, 0x0},
    {0x1600, 0x0000, 0, 'W', 4, 0x0, 0x0},
    {0x1600, 0x0002, 0, 'W', 4, 0x0, 0x0},
    {0x1600, 0x0004, 0, 'W', 4, 0x0, 0x0},
    {0x1600, 0x0006, 0, 'W', 4, 0x0, 0x0},
    {0x1600, 0x0008, 0, 'W', 4, 0x0, 0x0},
    {0x1600, 0x000A, 0, 'W', 4, 0x0, 0x0},
    {0x1600, 0x000C, 0, 'W', 4, 0x0, 0x0},
    {0x1600, 0x000E, 0, 'W', 4, 0x0, 0x0},
    {0x8000, 0x0000, 0, 'W', 4, 0x0, 0x0},
    {0x8000, 0x0004, 0, 'W', 4, 0x0, 0x0},
    {0x8000, 0x0008, 0, 'W', 4, 0x10, 0x0}
};

typedef struct PUNode {
    uint64_t key;
    uint32_t index;
    struct PUNode *next;
} PUNode;

#define PU_TABLE_SIZE ((uint64_t)(sizeof(registers) / sizeof(registers[0])))

PUNode *YUTable[PU_TABLE_SIZE] = {0};

static uint64_t pu_function(uint64_t key)
{
    return key % PU_TABLE_SIZE;
}

static uint64_t generate_key(uint32_t address, uint32_t offset)
{
    return ((uint64_t)address << 32) | offset;
}

void __attribute__((constructor)) pu_initialize_table(void)
{
    int i = 0;
    int table_size = sizeof(registers) / sizeof(registers[0]);

    for (i = 0; i < table_size; i++) {
        uint64_t key = generate_key(registers[i].address, registers[i].offset);
        uint64_t YUIndex = pu_function(key);

        PUNode *newNode = (PUNode *)malloc(sizeof(PUNode));
        newNode->key = key;
        newNode->index = i;
        newNode->next = NULL;

        if (YUTable[YUIndex] == NULL) {
            YUTable[YUIndex] = newNode;
        } else {
            PUNode *temp = YUTable[YUIndex];
            while (temp->next != NULL) {
                temp = temp->next;
            }
            temp->next = newNode;
        }
    }
}

void __attribute__((destructor)) pu_free_table(void)
{
    int i = 0;
    int table_size = sizeof(registers) / sizeof(registers[0]);
    for (i = 0; i < table_size; i++) {
        PUNode *node = YUTable[i];
        while (node != NULL) {
            PUNode *temp = node;
            node = node->next;
            free(temp);
        }
        YUTable[i] = NULL;
    }
}

uint32_t pu_search_id(uint32_t address, uint32_t offset)
{
    uint64_t key = generate_key(address, offset);
    uint64_t YUIndex = pu_function(key);

    PUNode *node = YUTable[YUIndex];
    while (node != NULL) {
        if (node->key == key) {
            return node->index;
        }
        node = node->next;
    }

    return 0;
}

uint32_t pu_get_address(uint32_t index)
{
    return registers[index].address;
}

uint32_t pu_get_offset(uint32_t index)
{
    return registers[index].offset;
}

uint32_t pu_get_status(uint32_t index)
{
    return registers[index].status;
}

void pu_set_status(uint32_t index, uint32_t status)
{
    registers[index].status = status;
}

char pu_get_type(uint32_t index)
{
    return registers[index].type;
}

uint32_t pu_get_length(uint32_t index)
{
    return registers[index].length;
}

uint32_t pu_get_data(uint32_t index)
{
    return registers[index].data;
}

uint8_t pu_get_command(uint32_t index)
{
    return (uint8_t)registers[index].command;
}

void pu_set_data(uint32_t index, uint32_t data)
{
    registers[index].data = data;
}

uint16_t calculate_crc16(const uint8_t *data, uint16_t length)
{
#define POLYNOMIAL (0x11021) // Calculate the CRC-16-CCITT (XMODEM)
    uint16_t crc = 0xFFFF;
    uint16_t i, j;
    for (i = 0; i < length; i++) {
        crc ^= (data[i] << 8);
        for (j = 8; j > 0; j--) {
            if (crc & 0x8000) {
                crc = (crc << 1) ^ POLYNOMIAL;
            } else {
                crc <<= 1;
            }
        }
    }
    return crc & 0xFFFF;
}

Bufdata createBufdata(uint16_t address, uint16_t offset, uint32_t data)
{
    Bufdata buf;
    buf.address = address;
    buf.offset = offset;
    buf.data = data;
    return buf;
}

CommFrame *createCommFrame(uint8_t addressID, uint8_t functionCode, uint16_t dataCount)
{
    CommFrame *frame = (CommFrame *)malloc(sizeof(CommFrame));
    if (!frame)
        return NULL;

    frame->addressID = addressID;
    frame->functionCode = functionCode;
    frame->dataCount = dataCount;

    if (dataCount > 0) {
        frame->dataField = (Bufdata *)malloc(dataCount * sizeof(Bufdata));
        if (!frame->dataField) {
            free(frame);
            return NULL;
        }
    } else {
        frame->dataField = NULL;
    }

    return frame;
}

uint8_t *serializeCommFrame(CommFrame *frame, uint16_t *data_size)
{
    uint16_t bufferSize = sizeof(frame->addressID) + sizeof(frame->functionCode) + sizeof(frame->dataCount) + sizeof(frame->crcCheck) + (frame->dataCount * sizeof(Bufdata));
    uint8_t *buffer = (uint8_t *)malloc(bufferSize);
    if (!buffer) {
        PRINT_ERROR("%p\n", buffer);
        return NULL;
    }

    uint16_t index = 0;
    buffer[index++] = frame->addressID;
    buffer[index++] = frame->functionCode;
    buffer[index++] = (frame->dataCount >> 8) & 0xFF;
    buffer[index++] = frame->dataCount & 0xFF;
    int i = 0;
    for (i = 0; i < frame->dataCount; i++) {
        buffer[index++] = (frame->dataField[i].address >> 8) & 0xFF;
        buffer[index++] = frame->dataField[i].address & 0xFF;
        buffer[index++] = (frame->dataField[i].offset >> 8) & 0xFF;
        buffer[index++] = frame->dataField[i].offset & 0xFF;
        buffer[index++] = (frame->dataField[i].data >> 24) & 0xFF;
        buffer[index++] = (frame->dataField[i].data >> 16) & 0xFF;
        buffer[index++] = (frame->dataField[i].data >> 8) & 0xFF;
        buffer[index++] = frame->dataField[i].data & 0xFF;
    }

    frame->crcCheck = calculate_crc16(buffer, index);
    buffer[index++] = (frame->crcCheck >> 8) & 0xFF;
    buffer[index++] = frame->crcCheck & 0xFF;

    *data_size = bufferSize;
    return buffer;
}

void freeCommFrame(CommFrame *frame)
{
    if (frame) {
        if(frame->dataField) {
            free(frame->dataField);
            frame->dataField = NULL;
        }
        free(frame);
        frame = NULL;
    }
}

CommFrame *copy_received_frame(const CommFrame *frame)
{
    if (!frame || !frame->dataField) {
        return NULL;
    }

    CommFrame *new_frame = (CommFrame *)malloc(sizeof(CommFrame));
    if (!new_frame) {
        PRINT_ERROR("%p\n", new_frame);
        return NULL;
    }

    memcpy(new_frame, frame, sizeof(CommFrame));

    new_frame->dataField = (Bufdata *)malloc(sizeof(Bufdata) * frame->dataCount);
    if (!new_frame->dataField) {
        PRINT_ERROR("%p\n", new_frame->dataField);
        free(new_frame);
        return NULL;
    }

    memcpy(new_frame->dataField, frame->dataField, sizeof(Bufdata) * frame->dataCount);

    return new_frame;
}

void free_copied_frame(CommFrame *frame)
{
    if (frame) {
        if (frame->dataField) {
            free(frame->dataField);
            frame->dataField = NULL;
        }
        free(frame);
        frame = NULL;
    }
}